<!DOCTYPE html><html lang="en" dir="ltr"> <!-- for mathjax support --> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ TeX: { equationNumbers: { autoNumber: "AMS" } } }); </script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"> </script><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="X-UA-Compatible" content="ie=edge"><title>Platonic Hask overview: subcategories, functors and natural transformations | Vitalii Guzeev</title><meta name="description" content="Blog and entry point to my online appearance"><link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/favicon.ico" type="image/x-icon"><link href='/feed.xml' rel='alternate' type='application/atom+xml'><link rel="canonical" href="/blog/platonic-hask-overview-subcategories-functors-and-natural-transformations"><link rel="stylesheet" href="/assets/style.css"><body><main><h2 class="title">Vitalii Guzeev</h2><nav> <a href="http://localhost:4000">Home</a> <a href="http://localhost:4000/blog">Blog</a> <a href="http://localhost:4000/links.html">Links</a> <a href="http://localhost:4000/LICENSE.html">License</a> <a href="http://localhost:4000/usr.html">Face2face</a> <a href="https://github.com/viviag/viviag.io/issues">[Discuss]</a></nav><h1>Platonic Hask overview: subcategories, functors and natural transformations</h1><i>Aug 17, 2022</i><h4 class="subtitle"></h4><p>We have constructed the category of restricted Haskell types. There is nothing particularly useful in this construction yet. We need additional structure.</p><p>Consider categories \(\mathrm{C}\) and \(\mathrm{D}\) with pair of mappings \(F_{\operatorname{Ob}} :: \operatorname{Ob}(\mathrm{C}) \to \operatorname{Ob}(\mathrm{D})\) and \(F_{\operatorname{Hom}}\) with one of the following signatures: \(\operatorname{Hom}_{\mathrm{C}}(A,B) \to \operatorname{Hom}_{\mathrm{D}}(F_{\operatorname{Ob}}(A),F_{\operatorname{Ob}}(B))\) or \(\operatorname{Hom}_{\mathrm{C}}(A,B) \to \operatorname{Hom}_{\mathrm{D}}(F_{\operatorname{Ob}}(B),F_{\operatorname{Ob}}(A))\) — mapping of all morphisms of a category, defined on each Hom-set. \(F = (F_{\operatorname{Ob}}, F_{\operatorname{Hom}})\) represents mapping between categories.</p><h5 id="definitions">Definitions</h5><p>\(F\) is a called a <strong>covariant functor</strong> or <strong>functor</strong> if the following diagram commutes:</p><p><img src="/assets/functor.svg" alt="functor" /></p><p>is a called a <strong>contravariant functor</strong> if the following diagram commutes:</p><p><img src="/assets/cofunctor.svg" alt="functor" /></p><p>These two definitions are related to notion of <strong>dual category</strong> — category \(\mathrm{C}^{op}\) is constructed from \(\mathrm{C}\) by formally reverting all arrows in a diagram of \(\mathrm{C}\). This notion allows us to identify contravariant functor \(F :: \mathrm{C} \to \mathrm{D}\) with covariant \(F^{op} :: \mathrm{C} \to \mathrm{D}^{op}\).</p><p>Here are several useful definitions:</p><p>Let \(F :: \mathrm{C} \to \mathrm{D}\) be a functor (covariant, contravariant definitions are similar). Consider \(F_{\operatorname{Hom}}\).</p><p>If \(\forall A, B \in \mathrm{C}\; F_{\operatorname{Hom}} :: \operatorname{Hom}_{\mathrm{C}}(A,B) \to \operatorname{Hom}_{\mathrm{D}}(F_{\operatorname{Ob}}(A),F_{\operatorname{Ob}}(B))\) is injective, \(F\) is called <strong>faithful</strong>. If surjective — <strong>full</strong>. If bijective — <strong>fully faithful</strong>.</p><p>We have constructed the category and consider its internal structure. Functors from category to itself are called <strong>endofunctors</strong>. However, it may be convenient to talk about subcategories in and about functors to them.</p><h5 id="definition">Definition</h5><p>Category \(\mathrm{D}\) is a subcategory of \(\mathrm{C}\) if \(\operatorname{Ob}(\mathrm{D}) \subseteq \operatorname{Ob}(\mathrm{C})\) and \(\forall A,B \in \operatorname{Ob}(\mathrm{D})\; \operatorname{Hom}_{\mathrm{D}}(A,B) \subseteq \operatorname{Hom}_{\mathrm{C}}(A,B)\).</p><p>If \(\forall A,B \in \operatorname{Ob}(\mathrm{D})\; \operatorname{Hom}_{\mathrm{D}}(A,B) = \operatorname{Hom}_{\mathrm{C}}(A,B)\) \(\mathrm{D}\) is called <strong>full subcategory</strong> of \(\mathrm{C}\).</p><p>Every subcategory gives rise to faithful embedding functor \(Emb :: \mathrm{D} \to \mathrm{C}\) with identical actions both on objects and morphisms. If \(\mathrm{D}\) is a full subcategory \(Emb\) is fully faithful.</p><p>Now let’s take a look at functors in Hask.</p><h5 id="example-functor-typeclass-and-parametric-types">Example: Functor typeclass and parametric types</h5><p>Consider declaration of new data type like <code class="language-plaintext highlighter-rouge">data Either a b = Left a | Right b</code>.</p><p>There are several possible constructions of -endofunctor arising from this definition. Two most native (except \(Emb\)) are defined here:</p><ol><li>\(Left_{\operatorname{Ob}}(a :: a)\) = <code class="language-plaintext highlighter-rouge">Left a</code>; \(Left_{\operatorname{Hom}}(f :: a \to c)\) = <code class="language-plaintext highlighter-rouge">(\Left a -&gt; Left (f a))</code>.<li>\(Right_{\operatorname{Ob}}(a :: b)\) = <code class="language-plaintext highlighter-rouge">Right a</code>; \(Right_{\operatorname{Hom}}(f :: b \to c)\) = <code class="language-plaintext highlighter-rouge">(\Right a -&gt; Right (f a))</code>.</ol><p>Both of them are well-defined covariant faithful functors in \(Hask\).</p><p>Moreover, each parametric type form a full subcategory in \(Hask\), hence these functors can be considered as \(Hask \to Either\). Or 2. can be considered as functor \(Hask \to Either\;a\).</p><p>However, only \(Right\) is supported by valid <code class="language-plaintext highlighter-rouge">Functor</code> instance in Haskell. Instance for <code class="language-plaintext highlighter-rouge">Either</code>:</p><div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">c</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">fmap</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span>  <span class="n">f</span> <span class="n">b</span><span class="p">)</span>
  <span class="n">fmap</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">Left</span> <span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Left</span> <span class="n">x</span>
  <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Right</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Right</span> <span class="p">(</span><span class="n">f</span> <span class="n">y</span><span class="p">)</span>
</code></pre></div></div><p>Note: <code class="language-plaintext highlighter-rouge">fmap</code> defines action of functor on morphisms. We change <code class="language-plaintext highlighter-rouge">Prelude</code> definition for now — it is valid and will be justified in the next post.</p><p>Laws of <code class="language-plaintext highlighter-rouge">Functor</code> typeclass represent usual definition of functor via following diagram: <img src="/assets/hasfunctor.svg" alt="haskfunctor" /></p><p>Haskell does not allow to define <code class="language-plaintext highlighter-rouge">Functor</code>s over non-terminal parameters in its own terms.</p><p>Note that uniqueness and derivability of <code class="language-plaintext highlighter-rouge">Functor</code> is not an elementary question. Since it’s not a question of category theory, let me refer to <a href="https://stackoverflow.com/questions/19774904/are-functor-instances-unique">SO</a>.</p><p>Yet another restriction on Haskell <code class="language-plaintext highlighter-rouge">Functor</code> typeclass is that it does not allow functors between nontrivial subcategories of \(Hask\).</p><p>Example of such a functor: \(LM :: [] \to Maybe\);</p><p>\(LM_{\operatorname{Ob}}\) = <a href="https://hackage.haskell.org/package/base-4.17.0.0/docs/Data-Maybe.html#v:listToMaybe">listToMaybe</a>;</p><p>\(LM_{\operatorname{Hom}}\) = <code class="language-plaintext highlighter-rouge">\f -&gt; listToMaybe . f . maybeToList</code>.</p><p>This functor is fully faithful. It admits faithful functor to the other side:</p><p>\(ML_{\operatorname{Ob}}\) = <code class="language-plaintext highlighter-rouge">maybeToList</code>;</p><p>\(ML_{\operatorname{Hom}}\) = <code class="language-plaintext highlighter-rouge">\f -&gt; </code><code class="language-plaintext highlighter-rouge">maybeToList</code><code class="language-plaintext highlighter-rouge"> . f . listToMaybe</code>.</p><h5 id="example-hom-functors">Example: Hom-functors</h5><p>For any category \(\mathrm{C}\) and object \(A\) there exist two functors.</p><p>First — \(\operatorname{Hom}(A,\_) :: \mathrm{C} \to Set\) is a covariant functor, moving \(X\) to \(\operatorname{Hom}(A,X)\). Second — contravariant \(\operatorname{Hom}(\_,A)\) with same signature, moving \(X\) to \(\operatorname{Hom}(X,A)\).</p><p>Both functors matters a lot for future constructions and obviously exist in \(Hask\).</p><p>Morphisms — functions between types, hence arrows <code class="language-plaintext highlighter-rouge">a -&gt; b</code>. They are ordinary types, hence their prefix form is <code class="language-plaintext highlighter-rouge">(-&gt;) a b</code> and there can only exist <code class="language-plaintext highlighter-rouge">Functor</code> instance for covariant \(\operatorname{Hom}\).</p><p>Here it is (note that fully applied <code class="language-plaintext highlighter-rouge">(-&gt;)</code> is a function):</p><div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">((</span><span class="o">-&gt;</span><span class="p">)</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">fmap</span> <span class="n">f</span> <span class="n">g</span> <span class="o">=</span> <span class="n">f</span> <span class="o">.</span> <span class="n">g</span>
</code></pre></div></div><p>Let’s define alternating type <code class="language-plaintext highlighter-rouge">&lt;-</code> isomorphic to <code class="language-plaintext highlighter-rouge">(-&gt;) b a</code>.</p><p>For this type we can define instance of <a href="https://hackage.haskell.org/package/contravariant-1.4/docs/Data-Functor-Contravariant.html">Contravariant</a>, which represent contravariant functors.</p><div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Contravariant</span> <span class="p">((</span><span class="o">&lt;-</span><span class="p">)</span> <span class="n">b</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">contramap</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
  <span class="n">contramap</span> <span class="n">f</span> <span class="n">g</span> <span class="o">=</span> <span class="n">g</span> <span class="o">.</span> <span class="n">f</span>
</code></pre></div></div><p>Laws of <code class="language-plaintext highlighter-rouge">Contravariant</code> form the following familiar diagram:</p><p><img src="/assets/hascofunctor.svg" alt="haskcofunctor" /></p><h5 id="other-useful-examples">Other useful examples</h5><ul><li>Forgetful functors from category to \(Set\) — ones forgetting all the structure imposed on objects and morphisms. For example, forgetful functor from category of groups \(Grp\) moves group to set of its elements and homomorphism to itself as a function between sets.<li>Free functors from \(Set\) to some category — ones which allow to impose defining relations of a category on a set and thus define free object in a category. For example, free functor from \(Set\) to \(Grp\) yields the group called free with presentation \(set \mapsto \{set\;|\;\emptyset\}\).<li>Tensor product with fixed object (left or right).<li>To say it out — basic example is identity functor.</ul><p>All these examples will appear not only in \(Hask\), but in Haskell.</p><h5 id="definition-1">Definition</h5><p>Consider \(F,G\), — covariant functors from \(\mathrm{C}\) to \(\mathrm{D}\). We will call family \(\eta\) of morphisms in \(\mathrm{D}\) <strong>natural transformation</strong> from \(F\) to \(G\) if for any object \(X\) in \(\operatorname{Ob}(C)\) and morphism \(f :: X \to Y\) there exist morphisms \(\eta_X :: F(X) \to G(X)\) and \(\eta_Y :: F(Y) \to G(Y)\) in \(\mathrm{D}\) such that \(\forall f \in \operatorname{Hom}_{\mathrm{C}}(X,Y)\) the following diagram commutes:</p><p><img src="/assets/natural.svg" alt="natural" /></p><p>If both functors are contravariant, vertical arrows are reversed.</p><p>This definition lets us to see \(LM\)-functor from the other side — as natural transformation between endofunctors \([]\) and \(Maybe\). Naturality is checked by the same reasoning as being a functor.</p><p>Haskell ecosystem contains several packages trying to express natural transformation. For example, <a href="https://hackage.haskell.org/package/natural-transformation">natural-transformation</a> package.</p><p>It’s worth noting that popular <a href="https://hackage.haskell.org/package/servant-server-0.10/docs/Servant-Server.html#v:enter">servant (0.10, link to enter function)</a> web-framework used to use explicitly typed natural transformations very close to its user interface for a long time. Here is how it was used: <a href="https://docs.servant.dev/en/v0.10/tutorial/Server.html">v0.10 tutorial</a></p><h5 id="statement">Statement</h5><p>Functors (covariant without loss of generality) between tho categories \(\mathrm{C}\) and \(\mathrm{C}\) with objects — functors and morphisms — natural transformations form a category.</p><p>This is well-known statement not about \(Hask\) with obvious proof by construction, so it will not be given.</p><p>Note that in example above \(LM \circ ML = Id_{Maybe}\).</p><p>This category of functors is denoted as \(\operatorname{Fun}(C,D)\). \(\operatorname{Fun}(C,C)\) has a more convenient synonym — \(\operatorname{End}(C)\).</p><p>We come up with another notable object we will use in the future — category \(\operatorname{End}(Hask)\) of endofunctors of \(Hask\).</p></main><footer> <a href="/blog">← Back to all writings</a> <!--<nav class="sans"><hr> <input class="menu-btn" type="checkbox" id="menu-btn" /><p><label class="menu-icon" for="menu-btn">Menu</label></p><ul class="site-nav"><li><a href="/">Home</a><li><a href="/blog">Blog</a><li><a href="/designs">Designs</a><li><a href="/about">About</a><li><a href="https://canisee.xyz" title="Confirm your vision functionality">[Can I See]</a></ul></nav>--> <!-- <span class="mini-note">You've reached the end of the page. Good job!</span> --> <!--<nav class="sans"><hr><p><label class="menu-icon" for="menu-btn">Menu</label></p><ul class="site-nav"><li><a href="/">Home</a><li><a href="/blog">Blog</a><li><a href="/designs">Designs</a><li><a href="/about">About</a><li><a href="https://canisee.xyz" title="Confirm your vision functionality">[Can I See]</a></ul></nav>--><div class="bottom-footer"> <i>Theme <a href="https://knhash.in/jekyllBear" title="the art">jekyllBear</a> built and maintained by <a href="https://knhash.in" title="the artist">knhash</a> </i></div></footer><!-- <script type="text/x-mathjax-config"> MathJax.Hub.Config({ extensions: ["tex2jax.js", "TeX/AMSmath.js"], jax: ["input/TeX", "output/SVG"], }) </script> <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=default"> </script> -->
