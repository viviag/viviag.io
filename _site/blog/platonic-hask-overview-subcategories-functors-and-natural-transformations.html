<!DOCTYPE html><html lang="en" dir="ltr"> <!-- for mathjax support --> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ TeX: { equationNumbers: { autoNumber: "AMS" } } }); </script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"> </script><head> <!-- Google tag (gtag.js) --> <script async src="https://www.googletagmanager.com/gtag/js?id=G-2EM85N0LNV"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-2EM85N0LNV'); </script> <!-- Yandex.Metrika counter --> <script type="text/javascript" > (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)}; m[i].l=1*new Date(); for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }} k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)}) (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym"); ym(94301673, "init", { clickmap:true, trackLinks:true, accurateTrackBounce:true }); </script> <noscript><div><img src="https://mc.yandex.ru/watch/94301673" style="position:absolute; left:-9999px;" alt="" /></div></noscript> <!-- /Yandex.Metrika counter --><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="X-UA-Compatible" content="ie=edge"><title>Platonic Hask overview: subcategories, functors, and natural transformations | Vitalii Guzeev</title><meta name="description" content="Blog and entry point to my online appearance"><link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/favicon.ico" type="image/x-icon"><link href='/feed.xml' rel='alternate' type='application/atom+xml'><link rel="canonical" href="/blog/platonic-hask-overview-subcategories-functors-and-natural-transformations"><link rel="stylesheet" href="/assets/style.css"><body><main><h2 class="title">Vitalii Guzeev</h2><nav> <a href="http://localhost:4000">Home</a> <a href="http://localhost:4000/blog">Blog</a> <a href="http://localhost:4000/links.html">Links</a> <a href="http://localhost:4000/LICENSE.html">License</a> <a href="http://localhost:4000/usr.html">Face2face</a> <a href="https://github.com/viviag/viviag.io/issues">[Discuss]</a> <a href="/feed.xml">[RSS]</a></nav><h1>Platonic Hask overview: subcategories, functors, and natural transformations</h1><i>Aug 17, 2022</i><h4 class="subtitle"></h4><p><em><a href="https://viviag.io/tagged/hask/">To index of the series</a></em></p><p>We have constructed the category of restricted Haskell types. It gave us a coherent notion of composition. But it’s not enough. The major strength of Haskell is its separation of computations of different natures. So we need to be able at least to cluster types into objects with some common property. Let’s develop machinery to deal with it.</p><p>Consider categories \(\mathrm{C}\) and \(\mathrm{D}\) with pair of mappings \(F_{\operatorname{Ob}} : \operatorname{Ob}(\mathrm{C}) \to \operatorname{Ob}(\mathrm{D})\) and \(F_{\operatorname{Hom}}\) with one of the following signatures: \(\operatorname{Hom}_{\mathrm{C}}(A,B) \to \operatorname{Hom}_{\mathrm{D}}(F_{\operatorname{Ob}}(A),F_{\operatorname{Ob}}(B))\) or \(\operatorname{Hom}_{\mathrm{C}}(A,B) \to \operatorname{Hom}_{\mathrm{D}}(F_{\operatorname{Ob}}(B),F_{\operatorname{Ob}}(A))\) — mapping of all morphisms of a category, defined on each Hom-set.</p><p>We can construct a pair \(F = (F_{\operatorname{Ob}}, F_{\operatorname{Hom}})\). Its definition contains all data necessary to define a map between categories. But the composition of such maps is not well-defined (check it). It can be fixed by the following definitions:</p><h5 id="definitions">Definitions</h5><p>\(F\) is called a <strong>covariant functor</strong> or <strong>functor</strong> if the following diagram commutes:</p><p><img src="/assets/functor.svg" alt="functor" /></p><p>or a <strong>contravariant functor</strong> if the following diagram commutes:</p><p><img src="/assets/cofunctor.svg" alt="functor" /></p><p>Here are several useful definitions:</p><p>Let \(F : \mathrm{C} \to \mathrm{D}\) be a functor (covariant, contravariant definitions are similar). Consider \(F_{\operatorname{Hom}}\).</p><p>If \(\forall A, B \in \mathrm{C}\; F_{\operatorname{Hom}} : \operatorname{Hom}_{\mathrm{C}}(A,B) \to \operatorname{Hom}_{\mathrm{D}}(F_{\operatorname{Ob}}(A),F_{\operatorname{Ob}}(B))\) is injective, \(F\) is called <strong>faithful</strong>. If surjective — <strong>full</strong>. If bijective — <strong>fully faithful</strong>.</p><p>Categories \(\mathrm{C}\) and \(\mathrm{D}\) are said to be equivalent if there exists fully faithful functor \(F : \mathrm{C} \to \mathrm{D}\) such that every object of \(\mathrm{D}\) is isomorphic to \(F(A)\) for some \(A \in \operatorname{C}\).</p><p>We have constructed the category \(Hask\) and we have a notion of composable mappings between categories. Functors from category to itself are called <strong>endofunctors</strong>. However, it may be convenient to talk about subcategories in \(Hask\) and about functors between them.</p><p>Category \(\mathrm{D}\) is a subcategory of \(\mathrm{C}\) if \(\operatorname{Ob}(\mathrm{D}) \subseteq \operatorname{Ob}(\mathrm{C})\) and \(\forall A,B \in \operatorname{Ob}(\mathrm{D})\; \operatorname{Hom}_{\mathrm{D}}(A,B) \subseteq \operatorname{Hom}_{\mathrm{C}}(A,B)\).</p><p>If \(\forall A,B \in \operatorname{Ob}(\mathrm{D})\; \operatorname{Hom}_{\mathrm{D}}(A,B) = \operatorname{Hom}_{\mathrm{C}}(A,B)\) \(\mathrm{D}\) is called <strong>full subcategory</strong> of \(\mathrm{C}\).</p><p>Every subcategory gives rise to faithful embedding functor \(Emb : \mathrm{D} \to \mathrm{C}\) with identical actions both on objects and morphisms. If \(\mathrm{D}\) is a full subcategory, then \(Emb\) is fully faithful.</p><p>Now let’s take a look at functors in Hask.</p><h5 id="example-functor-typeclass-and-parametric-types">Example: Functor typeclass and parametric types</h5><p>Consider the declaration of new data type like <code class="language-plaintext highlighter-rouge">data Either a b = Left a | Right b</code>.</p><p>There are several possible constructions of \(Hask\)-endofunctor arising from this definition. The two most natural are defined here:</p><ol><li>\(Left_{\operatorname{Ob}}(a : a)\) = <code class="language-plaintext highlighter-rouge">Left a</code>; \(Left_{\operatorname{Hom}}(f : a \to c)\) = <code class="language-plaintext highlighter-rouge">(\Left a -&gt; Left (f a))</code>.<li>\(Right_{\operatorname{Ob}}(a : b)\) = <code class="language-plaintext highlighter-rouge">Right a</code>; \(Right_{\operatorname{Hom}}(f : b \to c)\) = <code class="language-plaintext highlighter-rouge">(\Right a -&gt; Right (f a))</code>.</ol><p>Both of them are well-defined covariant faithful endofunctors in \(Hask\). More specifically, \(Right\) is a functor to the category \(Either\;a\;\_\) and \(Left\) is a functor to the category \(Either\;\_\;b\).</p><p>However, only \(Right\) is supported by a valid <code class="language-plaintext highlighter-rouge">Functor</code> instance in Haskell. Instance for <code class="language-plaintext highlighter-rouge">Either</code>:</p><div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">c</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">fmap</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span>  <span class="n">f</span> <span class="n">b</span><span class="p">)</span>
  <span class="n">fmap</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">Left</span> <span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Left</span> <span class="n">x</span>
  <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Right</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Right</span> <span class="p">(</span><span class="n">f</span> <span class="n">y</span><span class="p">)</span>
</code></pre></div></div><p>Note: <code class="language-plaintext highlighter-rouge">fmap</code> defines the action of functor on morphisms. We change the <code class="language-plaintext highlighter-rouge">Prelude</code> definition for now — it is valid and will be justified in the next post.</p><p>Can \(Left\) functor be expressed? Yes:</p><div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">swap</span> <span class="o">::</span> <span class="kt">Either</span> <span class="n">b</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span>
<span class="n">swap</span> <span class="p">(</span><span class="kt">Right</span> <span class="n">a</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Left</span> <span class="n">a</span>
<span class="n">swap</span> <span class="p">(</span><span class="kt">Left</span> <span class="n">a</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Right</span> <span class="n">a</span>
 
<span class="n">fmap'</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">Either</span> <span class="n">c</span> <span class="n">b</span><span class="p">)</span>
<span class="n">fmap'</span> <span class="n">f</span> <span class="o">=</span> <span class="n">swap</span> <span class="o">.</span> <span class="n">fmap</span> <span class="n">f</span> <span class="o">.</span> <span class="n">swap</span>
</code></pre></div></div><p>But it cannot be expressed in terms of <code class="language-plaintext highlighter-rouge">Functor</code> typeclass as long as there is no single-parametric type <code class="language-plaintext highlighter-rouge">Either _ b</code> in Haskell. In particular, we see that not any subcategory of \(Hask\) is encapsulated in a type.</p><p>Note that the uniqueness and derivability of <code class="language-plaintext highlighter-rouge">Functor</code> is not an elementary question. Since it’s not a question of category theory, let me refer to <a href="https://stackoverflow.com/questions/19774904/are-functor-instances-unique">SO</a>.</p><p>Laws of the <code class="language-plaintext highlighter-rouge">Functor</code> typeclass represent the usual definition of functor via the following diagram: <img src="/assets/hasfunctor.svg" alt="haskfunctor" /></p><p>Yet another restriction on Haskell <code class="language-plaintext highlighter-rouge">Functor</code> typeclass is that it does not allow functors between nontrivial subcategories of \(Hask\).</p><p>Example of such a functor: \(LM : [] \to Maybe\);</p><p>\(LM_{\operatorname{Ob}}\) = <a href="https://hackage.haskell.org/package/base-4.17.0.0/docs/Data-Maybe.html#v:listToMaybe">listToMaybe</a>;</p><p>\(LM_{\operatorname{Hom}}\) = <code class="language-plaintext highlighter-rouge">\f -&gt; listToMaybe . f . maybeToList</code>.</p><p>This functor is fully faithful. It admits faithful functor to the other side:</p><p>\(ML_{\operatorname{Ob}}\) = <code class="language-plaintext highlighter-rouge">maybeToList</code>;</p><p>\(ML_{\operatorname{Hom}}\) = <code class="language-plaintext highlighter-rouge">\f -&gt; </code><code class="language-plaintext highlighter-rouge">maybeToList</code><code class="language-plaintext highlighter-rouge"> . f . listToMaybe</code>.</p><p>It’s easy to check that functor \(toList : Vector \to []\) with a similar definition makes subcategories of vectors and lists equivalent.</p><p>All three of these functors are not endofunctors in \(Hask\) since they are not everywhere defined.</p><h5 id="example-hom-functors">Example: Hom-functors</h5><p>For any category \(\mathrm{C}\) and object \(A\) there exist two functors.</p><p>First — \(\operatorname{Hom}(A,\_) : \mathrm{C} \to Set\) is a covariant functor, moving \(X\) to \(\operatorname{Hom}(A,X)\). Second — contravariant \(\operatorname{Hom}(\_,A)\) with the same signature, moving \(X\) to \(\operatorname{Hom}(X,A)\).</p><p>Both functors matter a lot for future constructions and obviously exist in \(Hask\).</p><p>Morphisms — functions between types, hence arrows <code class="language-plaintext highlighter-rouge">a -&gt; b</code>. They are ordinary types, hence their prefix form is <code class="language-plaintext highlighter-rouge">(-&gt;) a b</code> and there can only exist <code class="language-plaintext highlighter-rouge">Functor</code> instance for covariant \(\operatorname{Hom}\).</p><p>Here it is (note that fully applied <code class="language-plaintext highlighter-rouge">(-&gt;)</code> is a function):</p><div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">((</span><span class="o">-&gt;</span><span class="p">)</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">fmap</span> <span class="n">f</span> <span class="n">g</span> <span class="o">=</span> <span class="n">f</span> <span class="o">.</span> <span class="n">g</span>
</code></pre></div></div><p>Let’s define alternating type <code class="language-plaintext highlighter-rouge">&lt;-</code> isomorphic to <code class="language-plaintext highlighter-rouge">(-&gt;) b a</code>.</p><p>For this type, we can define an instance of <a href="https://hackage.haskell.org/package/contravariant-1.4/docs/Data-Functor-Contravariant.html">Contravariant</a>, which represent contravariant functors.</p><div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Contravariant</span> <span class="p">((</span><span class="o">&lt;-</span><span class="p">)</span> <span class="n">b</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">contramap</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
  <span class="n">contramap</span> <span class="n">f</span> <span class="n">g</span> <span class="o">=</span> <span class="n">g</span> <span class="o">.</span> <span class="n">f</span>
</code></pre></div></div><p>Laws of <code class="language-plaintext highlighter-rouge">Contravariant</code> form the following familiar diagram:</p><p><img src="/assets/hascofunctor.svg" alt="haskcofunctor" /></p><h5 id="other-useful-examples-of-functors">Other useful examples of functors</h5><ul><li>Forgetful functors from category to \(Set\) — ones forgetting all the structure imposed on objects and morphisms. For example, a forgetful functor from the category of groups \(Grp\) moves a group to a set of its elements and homomorphism to itself as a function between sets.<li>Free functors from \(Set\) to some category — ones which allow to force the defining relations of a category on a set and thus define a free object in a category. For example, free functor from \(Set\) to \(Grp\) yields the group called free with presentation \(set \mapsto \{set\;|\;\emptyset\}\).<li>The tensor product with a fixed object (left or right).<li>To say it out — basic example is identity functor.</ul><p>All these constructions are relevant to \(Hask\).</p><p>Let’s take a look at the introduced structures. At the level of types, we have types and morphisms between them. Morphisms can be surjective, injective, or bijective, in the last case they are isomorphisms. Now we turn to the level of subcategories of \(Hask\) and we have functors that can be full, faithful, or fully faithful. These properties are finer than properties of Set-level morphisms but they are similar in spirit.</p><p>At the moment we can take one of two steps:</p><ol><li>Broad: try to introduce some category of subcategories of \(Hask\) and explore it. Probably more than one if we want to take care of contravariant functors. Note that contravariant functors are covariant functors from the dual category — category with all arrows reversed.<li>Deep: try to stack the next layer and define morphisms between functors.</ol><p>For now, we follow the second path.</p><h5 id="definition">Definition</h5><p>Consider \(F,G\), — covariant functors from \(\mathrm{C}\) to \(\mathrm{D}\). We will call family \(\eta\) of morphisms in \(\mathrm{D}\) <strong>natural transformation</strong> from \(F\) to \(G\) if for any object \(X\) in \(\operatorname{Ob}(C)\) and morphism \(f : X \to Y\) there exist morphisms \(\eta_X : F(X) \to G(X)\) and \(\eta_Y : F(Y) \to G(Y)\) in \(\mathrm{D}\) such that \(\forall f \in \operatorname{Hom}_{\mathrm{C}}(X,Y)\) the following diagram commutes:</p><p><img src="/assets/natural.svg" alt="natural" /></p><p>If both functors are contravariant, vertical arrows are reversed.</p><p>This definition lets us see \(LM\)-functor from the other side — as a natural transformation between endofunctors \([]\) and \(Maybe\). Naturality is checked by the same reasoning as being a functor.</p><p>The Haskell ecosystem contains several packages trying to express natural transformation. For example, <a href="https://hackage.haskell.org/package/natural-transformation">natural-transformation</a> package.</p><p>It’s worth noting that popular <a href="https://hackage.haskell.org/package/servant-server-0.10/docs/Servant-Server.html#v:enter">servant (0.10, link to enter function)</a> web framework used to use explicitly typed natural transformations very close to its user interface for a long time. Here is how it was used: <a href="https://docs.servant.dev/en/v0.10/tutorial/Server.html">v0.10 tutorial</a></p><h5 id="statement">Statement</h5><p>Functors (covariant without loss of generality) between tho categories \(\mathrm{C}\) and \(\mathrm{D}\) with objects — functors and morphisms — natural transformations form a category.</p><p>This is a well-known statement not about \(Hask\) with obvious proof by construction, so it will not be given.</p><p>Note that in the example above \(LM \circ ML = Id_{Maybe}\).</p><p>This category of functors is denoted as \(\operatorname{Fun}(\mathrm{C},\mathrm{D})\). \(\operatorname{Fun}(\mathrm{C},\mathrm{C})\) has a more convenient synonym — \(\operatorname{End}(\mathrm{C})\) and is called category of endofunctors of \(\mathrm{C}\).</p><p>We come up with another notable object we will use in the future — category \(\operatorname{End}(Hask)\) of endofunctors of \(Hask\).</p></main><footer> <a href="/blog">← Back to all writings</a> <!--<nav class="sans"><hr> <input class="menu-btn" type="checkbox" id="menu-btn" /><p><label class="menu-icon" for="menu-btn">Menu</label></p><ul class="site-nav"><li><a href="/">Home</a><li><a href="/blog">Blog</a><li><a href="/designs">Designs</a><li><a href="/about">About</a><li><a href="https://canisee.xyz" title="Confirm your vision functionality">[Can I See]</a></ul></nav>--> <!-- <span class="mini-note">You've reached the end of the page. Good job!</span> --> <!--<nav class="sans"><hr><p><label class="menu-icon" for="menu-btn">Menu</label></p><ul class="site-nav"><li><a href="/">Home</a><li><a href="/blog">Blog</a><li><a href="/designs">Designs</a><li><a href="/about">About</a><li><a href="https://canisee.xyz" title="Confirm your vision functionality">[Can I See]</a></ul></nav>--><div class="bottom-footer"> <i>Theme <a href="https://knhash.in/jekyllBear" title="the art">jekyllBear</a> built and maintained by <a href="https://knhash.in" title="the artist">knhash</a> </i></div></footer><!-- <script type="text/x-mathjax-config"> MathJax.Hub.Config({ extensions: ["tex2jax.js", "TeX/AMSmath.js"], jax: ["input/TeX", "output/SVG"], }) </script> <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=default"> </script> -->
