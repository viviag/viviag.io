<!DOCTYPE html><html lang="en" dir="ltr"> <!-- for mathjax support --> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ TeX: { equationNumbers: { autoNumber: "AMS" } } }); </script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"> </script><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="X-UA-Compatible" content="ie=edge"><title>Platonic Hask overview: representable functors and monoidal category structures | Vitalii Guzeev</title><meta name="description" content="Blog and entry point to my online appearance"><link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/favicon.ico" type="image/x-icon"><link href='/feed.xml' rel='alternate' type='application/atom+xml'><link rel="canonical" href="/blog/platonic-hask-overview-monoidal-category-structure"><link rel="stylesheet" href="/assets/style.css"><body><main><h2 class="title">Vitalii Guzeev</h2><nav> <a href="http://localhost:4000">Home</a> <a href="http://localhost:4000/blog">Blog</a> <a href="http://localhost:4000/links.html">Links</a> <a href="http://localhost:4000/LICENSE.html">License</a> <a href="http://localhost:4000/usr.html">Face2face</a> <a href="https://github.com/viviag/viviag.io/issues">[Discuss]</a></nav><h1>Platonic Hask overview: representable functors and monoidal category structures</h1><i>Feb 23, 2023</i><h4 class="subtitle"></h4><p><em><a href="https://viviag.io/tagged/hask/">To index of the series</a></em></p><p>Here we leave indices of \(\operatorname{Hom}\)-sets to context, same for definitions of objects — each subsection operates fixed category.</p><h4 id="cartesian-closedness">Cartesian closedness</h4><h5 id="definitions">Definitions</h5><p>Category \(\mathrm{C}\) is called <strong>cartesian closed</strong> if it has terminal object, for all \(A,B \in \operatorname{Ob}(\mathrm{C})\) there exists a product \(A \times B\) and exponential object \(B^A\).</p><p>To define all relevant notions it is convenient (following <a href="http://gorod.bogomolov-lab.ru/ps/stud/homalg/1920/list.html">lectures in Russian by A. Gorodentsev</a>) to define <strong>representable functor</strong>.</p><p>Functor \(F :: \mathrm{C}^{op} \to Set\) is said to be <strong>representable</strong> if is it naturally isomorphic to \(\operatorname{Hom}(\_,A)\) for some \(A\). \(A\) is called <strong>representing object</strong> of functor \(F\). Representing object is unique up to canonical isomorphism.</p><p>Any representing object has associated <strong>universal property</strong>. Let’s see it by example.</p><p>Consider objects \(A,B \in \mathrm{C}\). If functor \(\operatorname{Hom}(\_,A) \times \operatorname{Hom}(\_,B)\) is representable, its representing object \(A \times B\) is called the <strong>product</strong> of \(A\) and \(B\).</p><p>Write this definition: \(\forall Y\; Hom(Y, A \times B) \cong \operatorname{Hom}(Y,A) \times \operatorname{Hom}(Y,B)\).</p><p>Setting \(Y = A \times B\) we obtain via this isomorphism pair of maps \(\pi_A :: A \times B \to A\) and \(\pi_B :: A \times B \to B\) which are images of \(Id_{A \times B}\) under isomorphism. They are called <strong>canonical projections</strong>. For arbitrary \(Y\) this isomorphism guarantees existence and uniqueness of map \(\phi :: Y \to A \times B\) for any pair of maps \(\psi_A :: Y \to A\) and \(\psi_B :: Y \to B\). There are maps \(\pi_A \circ \phi\) and \(\pi_B \circ \phi\), since isomorphism is natural, \(\pi_A \circ \phi = \psi_A\), \(\pi_B \circ \phi = \psi_B\).</p><p>Thus we obtain the universal property of a product:</p><p>For any \(Y\), \(f :: Y \to A\) and \(g :: Y \to B\) there exists map \(\phi :: Y \to A \times B\) such that the following diagram commutes:</p><p><img src="/assets/productprop.svg" alt="productprop" /></p><p>Analogously we call representing object of a functor \(\operatorname{Hom}(\_, \emptyset)\) <strong>terminal object</strong> of category \(\mathrm{C}\). By evaluating its universal property we have that it is the object \(T\) with exactly one morphism \(Y \to T\) for any \(Y\).</p><p>Assume \(\mathrm{C}\) has all binary products. Consider functor \(\operatorname{Hom}(\_ \times A, B)\). Its representing object \(B^A\) is called <strong>exponential object</strong>. Actually we defined it via isomorphism \(\operatorname{Hom}(Y, B^A) \cong \operatorname{Hom}(Y \times A, B)\) which may look familiar.</p><p>By taking \(Y = B^A\) we obtain map \(eval :: B^A \times A \to B\). We can draw the universal property:</p><p><img src="/assets/expprop.svg" alt="expprop" /></p><p>Usually terminal objects and products are defined in terms of limits. But limits are examples of representing object and are not really important here. We will turn back to them later.</p><h5 id="hask-is-cartesian-closed">Hask is cartesian closed</h5><p>To prove the statement in the header we have to demonstrate terminal object, exponentials and products.</p><p>Since morphisms in \(Hask\) do not have to preserve any structure the only candidates for terminal object are types with single term. These are types isomorphic to <code class="language-plaintext highlighter-rouge">()</code>. They are all isomorphic (admit invertible bijections between each other), hence there is no need to check universality.</p><p>Evaluation map of exponential object suggests object satisfying universal property for types <code class="language-plaintext highlighter-rouge">a, b</code> — it is <code class="language-plaintext highlighter-rouge">a -&gt; b</code>. Products are given by type with two natural projections — <code class="language-plaintext highlighter-rouge">(a,b)</code>.</p><p>Definition of exponential object gives us a natural isomorphism <code class="language-plaintext highlighter-rouge">(a,b) -&gt; c</code> \(\cong\) <code class="language-plaintext highlighter-rouge">a -&gt; (b -&gt; c)</code> for any types <code class="language-plaintext highlighter-rouge">a, b, c</code>. This isomorphism is called currying. In Haskell it is common and is reflected in both implementation and notation — type <code class="language-plaintext highlighter-rouge">a -&gt; b -&gt; c</code> is literally equivalent to <code class="language-plaintext highlighter-rouge">a -&gt; (b -&gt; c)</code> (which is known as partial evaluation) and is isomorphic to <code class="language-plaintext highlighter-rouge">(a,b) -&gt; c</code> via inverse functions <code class="language-plaintext highlighter-rouge">curry</code> and <code class="language-plaintext highlighter-rouge">uncurry</code>.</p><p>There is an important proposition that any cartesian closed category is closed symmetric monoidal category with tensor product given by product in sense of given universal property. Closedness is incapsulated into existence of all exponentials. So let’s proceed to definition of symmetric monoidal category.</p><h4 id="monoidal-category-structure">Monoidal category structure</h4><h5 id="definitions-1">Definitions</h5><p>Category \(\mathrm{C}\) is called <strong>monoidal</strong> if</p><ul><li>It is equipped with <strong>tensor product</strong> bifunctor \(\otimes :: \mathrm{C} \times \mathrm{C} \to \mathrm{C}\) and associator functor \(\alpha :: \mathrm{C} \to \mathrm{C}\) satisfying associative law.<li>There exists unit object \(I\) and unitor functors \(\lambda\), \(\rho\) satisfying identity law.<li>Both associator and unitor maps are natural isomorphisms where defined.</ul><p>Associativity law is the commutativity of the following diagram:</p><p><img src="/assets/monass.svg" alt="monass" /></p><p>Identity law is the commutativity of the following diagram:</p><p><img src="/assets/monid.svg" alt="monid" /></p><p>Monoidal category is called <strong>symmetric</strong> if \(\forall A,B\) there exists isomorphism \(s_{AB} :: A \otimes B \to B \otimes A\) such that the following diagram commutes:</p><p><img src="/assets/monsym.svg" alt="monsym" /></p><h5 id="hask">Hask</h5><p>From cartesian closedness there automatically follows that \(Hask\) is symmetric monoidal with \(\otimes =\)<code class="language-plaintext highlighter-rouge">(,)</code> and unit — <code class="language-plaintext highlighter-rouge">()</code>. Associator and unitor functors are obvious. Denote this structure as \((Hask, (,), ())\).</p><p>Consider \(End(Hask)\). It is a monoidal category with tensor product given by composition, unit — by <code class="language-plaintext highlighter-rouge">Identity</code> functor, and with identical unitors and associator. Denote this structure as \((End(Hask),\circ,Id)\).</p><p>These two statements will be central in next two posts.</p><h4 id="dual-counterparts">Dual counterparts</h4><p>Universal properties allows us to construct dual objects by formally reversing all arrows.</p><p>While doing it with already defined representing objects we obtain the following definitions:</p><ul><li>Initial object is defined as an object $I$ such that it has unique morphism to any other object<li>Coproduct is defined by the following diagram:</ul><p><img src="/assets/coprod.svg" alt="coprod" /></p><ul><li>Coexponential object is defined by the following diagram:</ul><p><img src="/assets/coexp.svg" alt="coexp" /></p><p>Category with initial object, all coexponentials and all binary coproducts is called <strong>cocartesian coclosed</strong>.</p><p>\(Hask\) does not have all coexponentials and is not cocartesian coclosed.</p><p>But it has all coproducts given by <code class="language-plaintext highlighter-rouge">Either a b</code> and it has initial object <code class="language-plaintext highlighter-rouge">Void</code>. This data is enough to equip \(Hask\) with another structure of monoidal category. Tensor product is given by coproduct and unit is given by initial object. Denote this structure as \((Hask, Either, Void)\).</p><h4 id="note-on-corepresentable-functors">Note on corepresentable functors</h4><p>These universal objects with reversed arrows can be defined via duals to representable functors.</p><p>Functor \(F :: \mathrm{C} \to Set\) is said to be <strong>corepresentable</strong> if is it naturally isomorphic to \(\operatorname{Hom}(A,\_)\) for some \(A\). \(A\) is called <strong>corepresenting object</strong> of functor \(F\). Representing object is unique up to canonical isomorphism.</p><p>Initial object corepresents \(\operatorname{Hom}(\emptyset, \_)\), \(A \coprod B\) corepresents \(\operatorname{Hom}(A,\_) \otimes \operatorname{Hom}(B,\_)\), coexponential corepresents \(\operatorname{Hom}(A, \_ \coprod A)\).</p><p>In \(Hask\) \(\operatorname{Hom}(A,\_)\) is written as <code class="language-plaintext highlighter-rouge">(-&gt;) A</code>. We can restrict functors to instances of <code class="language-plaintext highlighter-rouge">Functor</code> type class and obtain the following definition of representable functor: functor <code class="language-plaintext highlighter-rouge">F</code> is said to be representable if there exists natural isomorphism between <code class="language-plaintext highlighter-rouge">F a</code> and <code class="language-plaintext highlighter-rouge">(-&gt;) A a</code> for every type <code class="language-plaintext highlighter-rouge">a</code>. <code class="language-plaintext highlighter-rouge">A</code> is corepresenting object of <code class="language-plaintext highlighter-rouge">F</code>. But <code class="language-plaintext highlighter-rouge">F</code> must be considered as a functor to Set with values — sets of terms of resulting types of <code class="language-plaintext highlighter-rouge">Functor</code> we started with instead of types.</p><p>This definition is captured in package <a href="https://hackage.haskell.org/package/representable-functors-3.2.0.2/docs/Data-Functor-Representable.html">representable-functors</a>. Isomorphism <code class="language-plaintext highlighter-rouge">Cons a ~ A -&gt; a</code> in terms of this library is written as <code class="language-plaintext highlighter-rouge">f a ~ Key a -&gt; a</code>, to the left it is given by <code class="language-plaintext highlighter-rouge">tabulate</code>, to the right by <code class="language-plaintext highlighter-rouge">index</code>.</p></main><footer> <a href="/blog">← Back to all writings</a> <!--<nav class="sans"><hr> <input class="menu-btn" type="checkbox" id="menu-btn" /><p><label class="menu-icon" for="menu-btn">Menu</label></p><ul class="site-nav"><li><a href="/">Home</a><li><a href="/blog">Blog</a><li><a href="/designs">Designs</a><li><a href="/about">About</a><li><a href="https://canisee.xyz" title="Confirm your vision functionality">[Can I See]</a></ul></nav>--> <!-- <span class="mini-note">You've reached the end of the page. Good job!</span> --> <!--<nav class="sans"><hr><p><label class="menu-icon" for="menu-btn">Menu</label></p><ul class="site-nav"><li><a href="/">Home</a><li><a href="/blog">Blog</a><li><a href="/designs">Designs</a><li><a href="/about">About</a><li><a href="https://canisee.xyz" title="Confirm your vision functionality">[Can I See]</a></ul></nav>--><div class="bottom-footer"> <i>Theme <a href="https://knhash.in/jekyllBear" title="the art">jekyllBear</a> built and maintained by <a href="https://knhash.in" title="the artist">knhash</a> </i></div></footer><!-- <script type="text/x-mathjax-config"> MathJax.Hub.Config({ extensions: ["tex2jax.js", "TeX/AMSmath.js"], jax: ["input/TeX", "output/SVG"], }) </script> <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=default"> </script> -->
