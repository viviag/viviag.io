<!DOCTYPE html><html lang="en" dir="ltr"> <!-- for mathjax support --><head> <!-- Google tag (gtag.js) --> <script async src="https://www.googletagmanager.com/gtag/js?id=G-2EM85N0LNV"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-2EM85N0LNV'); </script><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="X-UA-Compatible" content="ie=edge"><title>Case study: transitive closure computation in the wild | Vitalii Guzeev</title><meta name="description" content="Blog and entry point to my online appearance"><link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/favicon.ico" type="image/x-icon"><link href='/feed.xml' rel='alternate' type='application/atom+xml'><link rel="canonical" href="/blog/transitive-closure"><link rel="stylesheet" href="/assets/style.css"><body><main><h2 class="title">Vitalii Guzeev</h2><nav> <a href="http://localhost:4000">Home</a> <a href="http://localhost:4000/blog">Blog</a> <a href="http://localhost:4000/links.html">Links</a> <a href="http://localhost:4000/LICENSE.html">License</a> <a href="http://localhost:4000/usr.html">Face2face</a> <a href="https://github.com/viviag/viviag.io/issues">[Discuss]</a> <a href="/feed.xml">[RSS]</a></nav><h1>Case study: transitive closure computation in the wild</h1><i>Jul 15, 2024</i><h4 class="subtitle"></h4><p>In programmers’ education, at least in Russia, there is a strong competitive tradition. Students compete in olympiads and contests, these contests mainly consist of algorithmic problems. Especially authors of them like graph algorithms. Many people invest a lot into these skills and excel in solving algorithmic problems. Some of them become university professors and teach algorithms to a broader audience.</p><p>Some of them and whose they taught will use these skills outside of the tournament or the classroom once in next several years on an algorithmic section of their successful interview to Google. Algorithms from courses in discrete mathematics are not a part of daily work of many programmers. For some, they are. For me, they are not, but scope of issues reaching me in hope of being closed is broad enough to regularly involve implementation of some algorithm. Some of these issues can be easily disclosed for the public. Some of them contain encounters of algorithms, that may seem surprising at a first glance and leave a feeling as if you see a rare animal from your window. “Hey, look at it!”. This post is short and is likely of no interest for whose who see graph algorithms everyday.</p><h4 id="the-setting">The setting</h4><p>Assume you work on a big project. “Big” here means that it has several local packages with dependencies between them in a single repository. You have a build tool which can build the given set of packages or the whole project. In our case, the tool is <a href="https://docs.haskellstack.org/en/stable/">Stack</a> and the packages are a set of packages grouped under the same global configuration file (<code class="language-plaintext highlighter-rouge">stack.yaml</code>).</p><p>You also have a continuous integration set up. So you commit, system builds the code, deploys new executables to registry in a convenient form and then some tool look the registry updates up and deploy them to the applications cluster.</p><p>Packages are very different. Some of them are libraries. Some of them are stateful services. For these either some persistence should be designed or we have to accept that each restart leads to loss of the state. Some of them are high-throughput services. Restart of them under load may cause different types of troubles — sudden bottleneck while scaling replicas <code class="language-plaintext highlighter-rouge">n \to 1 \to n</code>, episodes of inconsistent behavior under some circumstances etc.</p><p>So it’s important not to restart application if it was not updated. The <code class="language-plaintext highlighter-rouge">stack install</code> command without arguments copies all the executables to folder with binaries regardless if they were updated or not. So we have to avoid it.</p><p>One possible solution is to parse the output of something like <code class="language-plaintext highlighter-rouge">git diff --stat</code> to get the list of changed packages and feed it to <code class="language-plaintext highlighter-rouge">stack install &lt;args&gt;</code>.</p><h4 id="the-problem">The problem</h4><p>The project has internal dependency relations. Assume we only change a library which is used in some executable. The solution proposed will lead to rebuild of the library, but no executable will be updated. Effectively the release will not happen.</p><p>This problem is easy to formalize. Packages with dependencies between them form an oriented graph. Let’s orient edges as <code class="language-plaintext highlighter-rouge">dependency -&gt; dependent</code>. The set of packages directly changed by update is a set of vertices. We need to find all vertices reachable from the set by dependency arrows, i.e. to find a transivite closure of a subgraph.</p><h4 id="the-solution">The solution</h4><p>The problem is very famous. Even <a href="https://en.wikipedia.org/wiki/Transitive_closure#Algorithms">wikipedia</a> lists a set of solutions. But we have this problem in the wild, hence it has an additional context.</p><p>In this case, the context is given by the input format. Stack is a smart tool which allows to print the local dependency graph by a <code class="language-plaintext highlighter-rouge">stack dot</code> command. It prints the <a href="https://en.wikipedia.org/wiki/DOT_(graph_description_language)">.dot</a> file and allows to skip writing a program to construct the graph from package-level configuration files.</p><p>The dot file it prints is organized as follows:</p><div class="language-dot highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">v1</span> <span class="o">-&gt;</span> <span class="nv">v2</span>
<span class="nv">v1</span> <span class="o">-&gt;</span> <span class="nv">v4</span>
<span class="nv">v2</span> <span class="o">-&gt;</span> <span class="nv">v3</span>
<span class="nv">v2</span> <span class="o">-&gt;</span> <span class="nv">v4</span>
<span class="nv">v3</span> <span class="o">-&gt;</span> <span class="nv">v4</span>
</code></pre></div></div><p>Id est it represents the graph as a list of edges grouped by the initial vertex. This is a ready to use representation to run a search like <a href="https://en.wikipedia.org/wiki/Breadth-first_search">breadth-first search</a>. On this size of a graph, we could exclude time complexity from consideration at all.</p><p>The breadth-first search differs from depth-first search and all other searches in the traversal order. In my input file I have the graph already traversed. As it is small by the nature of the setting, I can just run through this list of edges. How to do it — start with the initial list <code class="language-plaintext highlighter-rouge">l</code> of vertices and on each egde add the end vertex to <code class="language-plaintext highlighter-rouge">l</code> if the start is in <code class="language-plaintext highlighter-rouge">l</code>. Let’s refer to the positive case of this conditional by “use vertex”.</p><p>Single run will not solve the problem. Consider the example</p><div class="language-dot highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">a</span> <span class="o">-&gt;</span> <span class="nv">c</span>
<span class="nv">b</span> <span class="o">-&gt;</span> <span class="nv">d</span>
<span class="nv">c</span> <span class="o">-&gt;</span> <span class="nv">b</span>
</code></pre></div></div><p>On a single run starting from the single vertex <code class="language-plaintext highlighter-rouge">a</code>, the algorithm will find <code class="language-plaintext highlighter-rouge">c</code> and <code class="language-plaintext highlighter-rouge">b</code>, but skip <code class="language-plaintext highlighter-rouge">d</code>. So we traverse edges from unused vertices again until we fail to find anything new.</p><p>That’s it. For a long explanation based on algorithmic training there are plenty of recourses like <a href="https://www.geeksforgeeks.org/transitive-closure-of-a-graph-using-dfs/">this</a>.</p><h4 id="ps">P.S.</h4><p>The solution was designed under impression that Stack always rebuilds all the executables if <code class="language-plaintext highlighter-rouge">stack build</code> is called without specific targets. As <a href="https://github.com/mpilgrem">Mike Pilgrem</a> <a href="https://github.com/commercialhaskell/stack/issues/6622#issuecomment-2227093821">explains</a> to me, it is not true, so the problem is almost solvable by tracking the <code class="language-plaintext highlighter-rouge">last_modified</code> property of binaries coming from the build and from the build cache. His solution applied to my setting has the only one failure point — if the build cache on CI is unavailable, the procedure will redeploy everything. In-house implementation of the transitive closure algorithm does not depend on specific build properties. The optimal solution differs a bit, but does not involve custom code also.</p><h4 id="pps">P.P.S.</h4><p>From this point it’s quite easy to fall to mathematical discussion. The transitive closure problem can be solved using the Floyd-Warshall algorithm. As <a href="https://math-cs.spbu.ru/en/people/alexander-v-tiskin/">Alexander Tiskin</a> told me in January, it is essentially the Gauss algorithm in the tropical semiring. I hope to write some post on the algebraic path problem soon.</p></main><footer> <a href="/blog">← Back to all writings</a> <!--<nav class="sans"><hr> <input class="menu-btn" type="checkbox" id="menu-btn" /><p><label class="menu-icon" for="menu-btn">Menu</label></p><ul class="site-nav"><li><a href="/">Home</a><li><a href="/blog">Blog</a><li><a href="/designs">Designs</a><li><a href="/about">About</a><li><a href="https://canisee.xyz" title="Confirm your vision functionality">[Can I See]</a></ul></nav>--> <!-- <span class="mini-note">You've reached the end of the page. Good job!</span> --> <!--<nav class="sans"><hr><p><label class="menu-icon" for="menu-btn">Menu</label></p><ul class="site-nav"><li><a href="/">Home</a><li><a href="/blog">Blog</a><li><a href="/designs">Designs</a><li><a href="/about">About</a><li><a href="https://canisee.xyz" title="Confirm your vision functionality">[Can I See]</a></ul></nav>--><div class="bottom-footer"> <i>Theme <a href="https://knhash.in/jekyllBear" title="the art">jekyllBear</a> built and maintained by <a href="https://knhash.in" title="the artist">knhash</a> </i></div></footer><!-- <script type="text/x-mathjax-config"> MathJax.Hub.Config({ extensions: ["tex2jax.js", "TeX/AMSmath.js"], jax: ["input/TeX", "output/SVG"], }) </script> <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=default"> </script> -->
