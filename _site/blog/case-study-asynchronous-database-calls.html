<!DOCTYPE html><html lang="en" dir="ltr"> <!-- for mathjax support --> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ TeX: { equationNumbers: { autoNumber: "AMS" } } }); </script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"> </script><head> <!-- Yandex.Metrika counter --> <script type="text/javascript" > (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)}; m[i].l=1*new Date(); for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }} k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)}) (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym"); ym(94301673, "init", { clickmap:true, trackLinks:true, accurateTrackBounce:true }); </script> <noscript><div><img src="https://mc.yandex.ru/watch/94301673" style="position:absolute; left:-9999px;" alt="" /></div></noscript> <!-- /Yandex.Metrika counter --><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="X-UA-Compatible" content="ie=edge"><title>Case study: asynchronous database calls | Vitalii Guzeev</title><meta name="description" content="Blog and entry point to my online appearance"><link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/favicon.ico" type="image/x-icon"><link href='/feed.xml' rel='alternate' type='application/atom+xml'><link rel="canonical" href="/blog/case-study-asynchronous-database-calls"><link rel="stylesheet" href="/assets/style.css"><body><main><h2 class="title">Vitalii Guzeev</h2><nav> <a href="http://localhost:4000">Home</a> <a href="http://localhost:4000/blog">Blog</a> <a href="http://localhost:4000/links.html">Links</a> <a href="http://localhost:4000/LICENSE.html">License</a> <a href="http://localhost:4000/usr.html">Face2face</a> <a href="https://github.com/viviag/viviag.io/issues">[Discuss]</a> <a href="/feed.xml">[RSS]</a></nav><h1>Case study: asynchronous database calls</h1><i>Jan 18, 2023</i><h4 class="subtitle"></h4><p>This is a brief description of a problem setting and a solution adopted for checking answers given by students to <a href="http://7.math.ru/">Hypermath</a> system. It does not pretend to be a best practice, it’s just a working solution I came up with. It is not necessary to mention Hypermath through the text, but problem needs an illustrative example.</p><h4 id="actors">Actors</h4><p>Hypermath is a client-server application receiving requests via HTTP. It is connected with remote relational database and with remote in-memory storage mostly used as a database cache. Application is solidly orchestrated (thanks to <a href="https://www.linkedin.com/in/egor-kuzmichev/">Egor</a>) and supports rolling releases.</p><p>System is dedicated to serve as a teaching assistant for school teachers in mathematics. Its target audience is quite big hence system must work with high throughput. Specifics of the system yield an obvious critical point: testing of given answers.</p><h4 id="problem-statement">Problem statement</h4><p>When student press button “Check” the following actions must happen:</p><ol><li>Result of the check should be computed.<li>Result should be communicated to teachers of the student via websocket in order to maintain realtime statistics of their classes. During this step we ask database about list of teachers to receive the message. It seems not convenient to store mapping student-teacher in a cache.<li>Data describing the check request should be collected to database to be accessible in student’s statistics.</ol><p>At a first glance there is no problem with consecutive execution of these steps in a handler thread (server uses <a href="https://hackage.haskell.org/package/warp-3.3.23">warp</a>). But if we perform a load testing we immediately become quite disappointed by the result.</p><p>The hardest computation is performed during answer test itself. This step is absolutely unavoidable since student needs to see result immediately. If there was no solution to simplify this step post would be over.</p><p>But answer determines the check result. Hence check results can be cached. Every math problem is tested by people before publication to the system hence in practice all frequent answers are known to system prior to publication. Hence step 1 is actually very fast in overwhelming majority of cases.</p><p>This solution unlocks the problem I want to talk about. Given this sequence of required operations performed by a handler we have to redesign it and reduce latency of a request at an acceptable cost of delays in statistics updates. Importantly, we must guarantee data safety in case of emergency or, more frequently, new releases.</p><h4 id="adopted-solution">Adopted solution</h4><p>Header of the post suggests that some actions can be performed asynchronously.</p><p>In particular, both operations 2 and 3 can be performed asynchronously.</p><p>Let’s talk about 3 first. Since statistics is stored in a table with several indices write operations are better to be performed not very frequently. So we store data to cache at the same action as 2 and then a separate job periodically flushes it to database.</p><p>Naive approach to 2 is to simply (modulo explicit passing of computation context or accurate usage of <code class="language-plaintext highlighter-rouge">MonadBaseControl IO</code> or similar technique) put <code class="language-plaintext highlighter-rouge">forkIO</code> before action.</p><p>But wait. Consider the basic version of the handler and its behavior under load.</p><p>Assume we give load of 1000rps with throughput of a handler 100rps. Then we first see normal dynamics with 100rps and when near the response timeout a massive and exponentially increasing list of 504s. At some point application freezes. It is a freeze of a web-server running the app which is at capacity with waiting requests. Good model of server crash under load can be found <a href="https://www.linuxjournal.com/article/4878">here</a>.</p><p>Substantial part of the server latency comes from communication with database. Regarding PostgreSQL, there is a setting <code class="language-plaintext highlighter-rouge">max_connections</code> which limits number of simultaneously active sessions. It is recommended to keep it small because each connection is maintained by separate system process on a database host.</p><p>So assume we run computation which connects to database asynchronously and we give app a constant load of 1000rps. Indeed we see desired 1000rps for some time in a testing protocol. But in a background we have quickly reached <code class="language-plaintext highlighter-rouge">max_connections</code> . Hence all other handlers requesting database are put under stress and slowed down — we have allowed actually more attempts to connect than in consecutive implementations since web-server lets more requests to reach application in a moment. Moreover we have moved exponential growth in number of requests to application side. Hence we have created a little fork-bomb which eventually explodes and causes application to freeze in a process of context-switching. Green threads are lightweight but there are a lot of them.</p><p>This is the natural setting to introduce threadpools. However this approach is not widely used in Haskell, new threads can be created with almost no overhead. Solution we adopted is to limit number of simultaneously run limited computations using <code class="language-plaintext highlighter-rouge">QSem</code>.</p><p>Explicitly it is written as follows:</p><div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sem</span> <span class="o">&lt;-</span> <span class="n">getThreadPool</span>
<span class="n">liftBaseWith</span> <span class="p">(</span><span class="nf">\</span><span class="n">runInBase</span> <span class="o">-&gt;</span> <span class="n">forkIO</span>
                          <span class="o">.</span> <span class="n">bracket_</span> <span class="p">(</span><span class="n">waitQSem</span> <span class="n">sem</span><span class="p">)</span> <span class="p">(</span><span class="n">signalQSem</span> <span class="n">sem</span><span class="p">)</span>
                          <span class="o">$</span> <span class="n">runInBase</span> <span class="n">action</span>
             <span class="p">)</span>
</code></pre></div></div><p>where <code class="language-plaintext highlighter-rouge">sem</code> is a semaphore stored in global application context. We actually allow creation of new threads and only freeze before running heavy actions. But this is enough to avoid excess context-switching, most of the threads are locked. And indeed we limit burden on a database.</p><p>From this point handler works as expected. Cost applied — delays in receiving students’ statistics may become significant.</p><p>But what’s with data safety? Assume release comes during operation under stress. Orchestration system stops replaced service only when all requests to it are answered but it ignores silent computations. We get a risk of statistical data loss before write to cache, which is increased by increased delays.</p><p>To deal with it we had to implement graceful termination. It est we track number of active explicitly forked threads and upon receiving interceptible termination signal wait for them all to finish. Regarding handler threads we rely on warp’s graceful termination.</p><p>Example code of how threads can be counted is <a href="https://gist.github.com/viviag/107782396a0809acbac09123a0c4155c">here</a>. Note that semaphores also count threads but we need some concurrency primitive anyway to lock signal handler.</p><p>So here it is: caching, periodic flushes of cached data to database, asynchronous actions with limit on number of simultaneously run ones, and graceful termination primitive.</p></main><footer> <a href="/blog">← Back to all writings</a> <!--<nav class="sans"><hr> <input class="menu-btn" type="checkbox" id="menu-btn" /><p><label class="menu-icon" for="menu-btn">Menu</label></p><ul class="site-nav"><li><a href="/">Home</a><li><a href="/blog">Blog</a><li><a href="/designs">Designs</a><li><a href="/about">About</a><li><a href="https://canisee.xyz" title="Confirm your vision functionality">[Can I See]</a></ul></nav>--> <!-- <span class="mini-note">You've reached the end of the page. Good job!</span> --> <!--<nav class="sans"><hr><p><label class="menu-icon" for="menu-btn">Menu</label></p><ul class="site-nav"><li><a href="/">Home</a><li><a href="/blog">Blog</a><li><a href="/designs">Designs</a><li><a href="/about">About</a><li><a href="https://canisee.xyz" title="Confirm your vision functionality">[Can I See]</a></ul></nav>--><div class="bottom-footer"> <i>Theme <a href="https://knhash.in/jekyllBear" title="the art">jekyllBear</a> built and maintained by <a href="https://knhash.in" title="the artist">knhash</a> </i></div></footer><!-- <script type="text/x-mathjax-config"> MathJax.Hub.Config({ extensions: ["tex2jax.js", "TeX/AMSmath.js"], jax: ["input/TeX", "output/SVG"], }) </script> <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=default"> </script> -->
