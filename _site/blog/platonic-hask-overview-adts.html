<!DOCTYPE html><html lang="en" dir="ltr"> <!-- for mathjax support --> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ TeX: { equationNumbers: { autoNumber: "AMS" } } }); </script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"> </script><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="X-UA-Compatible" content="ie=edge"><title>Platonic Hask overview: algebraic data types as corollary of monoidal structure | Vitalii Guzeev</title><meta name="description" content="Blog and entry point to my online appearance"><link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/favicon.ico" type="image/x-icon"><link href='/feed.xml' rel='alternate' type='application/atom+xml'><link rel="canonical" href="/blog/platonic-hask-overview-adts"><link rel="stylesheet" href="/assets/style.css"><body><main><h2 class="title">Vitalii Guzeev</h2><nav> <a href="http://localhost:4000">Home</a> <a href="http://localhost:4000/blog">Blog</a> <a href="http://localhost:4000/links.html">Links</a> <a href="http://localhost:4000/LICENSE.html">License</a> <a href="http://localhost:4000/usr.html">Face2face</a> <a href="https://github.com/viviag/viviag.io/issues">[Discuss]</a></nav><h1>Platonic Hask overview: algebraic data types as corollary of monoidal structure</h1><i>Feb 25, 2023</i><h4 class="subtitle"></h4><h4 id="algebraic-data-types">Algebraic data types</h4><p>We have only considered binary products and coproducts. We can consider family of products of arbitrary arity defining them as representing objects of \(\Pi_{i \in I}\operatorname{Hom}(\_,A_i)\) for finite ordinals \(I\). This definition has a problem with \(I = 0\), we treat this case specially and define empty product as the terminal object. Universal properties of these objects can be drawn easily from the binary case.</p><p>\(Hask\) has all the finite products, for instance, product <code class="language-plaintext highlighter-rouge">(a,(b,c))</code> satisfy the universal property. This is an instance of general statement that a category with binary products and terminal objects has all finite products.</p><p>Usual binary product <code class="language-plaintext highlighter-rouge">(,)</code> serves as a tensor product in \((Hask, (,), ())\), hence it satisfies associativity law and these products can be written without too much parens. Haskell has this notion — there are tuples of length bigger than 2. But each of them is implemented separately in GHC and it doesn’t allow tuples of length above some finite number.</p><p>This number is big enough for most applications, but here we need it only to notice that it is not a notion Haskell uses for parens-free presentation of finite products. Used notion is the following:</p><div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">P3</span> <span class="o">=</span> <span class="kt">P3</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span>
</code></pre></div></div><p>This type is naturally isomorphic to <code class="language-plaintext highlighter-rouge">(a,b,c)</code> and is an example of product type.</p><p>Dually \(Hask\) has all finite coproducts (initial object is set to be empty coproduct), which follows from existence of <code class="language-plaintext highlighter-rouge">Either</code>. Again from monoidal structure \((Hask, Either, Void)\) we derive that parens-free notation is legal.</p><p>In Haskell coproducts are written as</p><div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">C3</span> <span class="o">=</span> <span class="kt">Cons1</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">Cons2</span> <span class="n">b</span> <span class="o">|</span> <span class="kt">Cons3</span> <span class="n">c</span>
</code></pre></div></div><p>This is an example of sum type.</p><p>How consider two types:</p><div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">type</span> <span class="kt">Mix1</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">Either</span> <span class="n">b</span> <span class="n">c</span><span class="p">)</span>
</code></pre></div></div><p>and</p><div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">type</span> <span class="kt">Mix2</span> <span class="o">=</span> <span class="kt">Either</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
</code></pre></div></div><p>It’s easy to see that they are canonically isomorphic, let’s write isomorphism down.</p><div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">iso</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Mix1</span> <span class="o">-&gt;</span> <span class="kt">Mix2</span><span class="p">,</span> <span class="kt">Mix2</span> <span class="o">-&gt;</span> <span class="kt">Mix1</span><span class="p">)</span>
<span class="n">iso</span> <span class="o">=</span> <span class="p">(</span><span class="n">mix1toMix2</span><span class="p">,</span> <span class="n">mix2toMix1</span><span class="p">)</span>

<span class="n">mix1toMix2</span> <span class="o">::</span> <span class="kt">Mix1</span> <span class="o">-&gt;</span> <span class="kt">Mix2</span>
<span class="n">mix1toMix2</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">Left</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Left</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="n">mix1toMix2</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">Right</span> <span class="n">c</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Right</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>

<span class="n">mix2toMix1</span> <span class="o">::</span> <span class="kt">Mix2</span> <span class="o">-&gt;</span> <span class="kt">Mix1</span>
<span class="n">mix2toMix1</span> <span class="p">(</span><span class="kt">Left</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">Left</span> <span class="n">b</span><span class="p">)</span>
<span class="n">mix2toMix1</span> <span class="p">(</span><span class="kt">Right</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">c</span><span class="p">))</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">Right</span> <span class="n">c</span><span class="p">)</span>
</code></pre></div></div><p>This isomorphism inductively generalises to arbitrary finite coproducts.</p><p>We have that tensor product <code class="language-plaintext highlighter-rouge">(,)</code> distributes with finite coproducts.</p><p>Assume we have arbitrary symmetric monoidal category with tensor product distributive over finite coproducts (frequently denoted as <em>symmetric monoidal category with finite coproducts</em>). Consider classes of isomorphic types and denote binary product as \(\cdot\), binary coproduct as \(+\), terminal object as \(1\), and initial object as \(0\).</p><p>Laws of monoidal categories we have built can be rewritten as follows:</p><ul><li> \[(a+b)+c=a+(b+c)\]<li> \[0 + a = a = a + 0\]<li> \[a + b = b + a\]<li> \[(a \cdot b) \cdot c = a \cdot (b \cdot c)\]<li> \[1 \cdot a = a = a \cdot 1\]<li> \[a \cdot b = b \cdot a\]</ul><p>Distributivity gives us equation \(a \cdot (b + c) = a \cdot b + a \cdot c\).</p><p>For any object \(a\) consider \(0 \cdot a\). <strong>Proposition:</strong> it satisfies universal property of initial object. Proof by reference to <a href="https://ncatlab.org/nlab/show/distributive+category">ncatlab: Proposition 2.2</a>. Hence \(0 \cdot a = 0\).</p><p>For category of finite sets this construction yields semiring of natural numbers, as Qiaochu Yuan <a href="https://math.stackexchange.com/questions/2582771/relationship-between-algebraic-data-types-and-the-set-of-real-numbers#comment5333054_2582817">points</a> out. This is an easy exercise and we can compare it with notation of finite ordinals used to compactly denote finite products at the start of the post.</p><p>We have also just shown that objects in \(Hask\) as a symmetric monoidal category with finite coproducts form a commutative semiring.</p><p>So Haskell types do. This construction seems to me a good answer to question why algebraic types are algebraic.</p></main><footer> <a href="/blog">← Back to all writings</a> <!--<nav class="sans"><hr> <input class="menu-btn" type="checkbox" id="menu-btn" /><p><label class="menu-icon" for="menu-btn">Menu</label></p><ul class="site-nav"><li><a href="/">Home</a><li><a href="/blog">Blog</a><li><a href="/designs">Designs</a><li><a href="/about">About</a><li><a href="https://canisee.xyz" title="Confirm your vision functionality">[Can I See]</a></ul></nav>--> <!-- <span class="mini-note">You've reached the end of the page. Good job!</span> --> <!--<nav class="sans"><hr><p><label class="menu-icon" for="menu-btn">Menu</label></p><ul class="site-nav"><li><a href="/">Home</a><li><a href="/blog">Blog</a><li><a href="/designs">Designs</a><li><a href="/about">About</a><li><a href="https://canisee.xyz" title="Confirm your vision functionality">[Can I See]</a></ul></nav>--><div class="bottom-footer"> <i>Theme <a href="https://knhash.in/jekyllBear" title="the art">jekyllBear</a> built and maintained by <a href="https://knhash.in" title="the artist">knhash</a> </i></div></footer><!-- <script type="text/x-mathjax-config"> MathJax.Hub.Config({ extensions: ["tex2jax.js", "TeX/AMSmath.js"], jax: ["input/TeX", "output/SVG"], }) </script> <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=default"> </script> -->
