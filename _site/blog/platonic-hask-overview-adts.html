<!DOCTYPE html><html lang="en" dir="ltr"> <!-- for mathjax support --> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ TeX: { equationNumbers: { autoNumber: "AMS" } } }); </script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"> </script><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="X-UA-Compatible" content="ie=edge"><title>Platonic Hask overview: algebraic data types as a corollary of monoidal structure | Vitalii Guzeev</title><meta name="description" content="Blog and entry point to my online appearance"><link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/favicon.ico" type="image/x-icon"><link href='/feed.xml' rel='alternate' type='application/atom+xml'><link rel="canonical" href="/blog/platonic-hask-overview-adts"><link rel="stylesheet" href="/assets/style.css"><body> <!-- Google tag (gtag.js) --> <script async src="https://www.googletagmanager.com/gtag/js?id=G-2EM85N0LNV"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-2EM85N0LNV'); </script><main><h2 class="title">Vitalii Guzeev</h2><nav> <a href="http://localhost:4000">Home</a> <a href="http://localhost:4000/blog">Blog</a> <a href="http://localhost:4000/links.html">Links</a> <a href="http://localhost:4000/LICENSE.html">License</a> <a href="http://localhost:4000/usr.html">Face2face</a> <a href="https://github.com/viviag/viviag.io/issues">[Discuss]</a> <a href="/feed.xml">[RSS]</a></nav><h1>Platonic Hask overview: algebraic data types as a corollary of monoidal structure</h1><i>Feb 25, 2023</i><h4 class="subtitle"></h4><p><em><a href="https://viviag.io/tagged/hask/">To index of the series</a></em></p><h4 id="algebraic-data-types">Algebraic data types</h4><p>We have only considered binary products and coproducts. We can consider a family of products of arbitrary arity defining them as representing objects of \(\Pi_{i \in I}\operatorname{Hom}(\_,A_i)\) for finite ordinals \(I\). This definition has a problem with \(I = 0\), we treat this case specially and define the empty product as the terminal object. Universal properties of these objects can be drawn easily from the binary case.</p><p>\(Hask\) has all the finite products, for instance, product <code class="language-plaintext highlighter-rouge">(a,(b,c))</code> satisfy the universal property. This is an instance of a general statement that a category with binary products and terminal objects has all finite products.</p><p>Usual binary product <code class="language-plaintext highlighter-rouge">(,)</code> serves as a tensor product in \((Hask, (,), ())\), hence it satisfies associativity law and these products can be written without too many parens. Haskell has this notion — there are tuples of length bigger than 2. But each of them is implemented separately in GHC and it doesn’t allow tuples of length above some finite number.</p><p>This number is big enough for most applications, but here we need it only to notice that it is not a notion Haskell uses for the parens-free presentation of finite products. The used notion is the following:</p><div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">P3</span> <span class="o">=</span> <span class="kt">P3</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span>
</code></pre></div></div><p>This type is naturally isomorphic to <code class="language-plaintext highlighter-rouge">(a,b,c)</code> and is an example of a product type.</p><p>Dually \(Hask\) has all finite coproducts (initial object is set to be empty coproduct), which follows from the existence of <code class="language-plaintext highlighter-rouge">Either</code>. Again from monoidal structure \((Hask, Either, Void)\) we derive that parens-free notation is legal.</p><p>In Haskell, coproducts are written as</p><div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">C3</span> <span class="o">=</span> <span class="kt">Cons1</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">Cons2</span> <span class="n">b</span> <span class="o">|</span> <span class="kt">Cons3</span> <span class="n">c</span>
</code></pre></div></div><p>This is an example of a sum type.</p><p>Now consider two types:</p><div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">type</span> <span class="kt">Mix1</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">Either</span> <span class="n">b</span> <span class="n">c</span><span class="p">)</span>
</code></pre></div></div><p>and</p><div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">type</span> <span class="kt">Mix2</span> <span class="o">=</span> <span class="kt">Either</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
</code></pre></div></div><p>It’s easy to see that they are canonically isomorphic, let’s write isomorphism down.</p><div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">iso</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Mix1</span> <span class="o">-&gt;</span> <span class="kt">Mix2</span><span class="p">,</span> <span class="kt">Mix2</span> <span class="o">-&gt;</span> <span class="kt">Mix1</span><span class="p">)</span>
<span class="n">iso</span> <span class="o">=</span> <span class="p">(</span><span class="n">mix1toMix2</span><span class="p">,</span> <span class="n">mix2toMix1</span><span class="p">)</span>

<span class="n">mix1toMix2</span> <span class="o">::</span> <span class="kt">Mix1</span> <span class="o">-&gt;</span> <span class="kt">Mix2</span>
<span class="n">mix1toMix2</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">Left</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Left</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="n">mix1toMix2</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">Right</span> <span class="n">c</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Right</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>

<span class="n">mix2toMix1</span> <span class="o">::</span> <span class="kt">Mix2</span> <span class="o">-&gt;</span> <span class="kt">Mix1</span>
<span class="n">mix2toMix1</span> <span class="p">(</span><span class="kt">Left</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">Left</span> <span class="n">b</span><span class="p">)</span>
<span class="n">mix2toMix1</span> <span class="p">(</span><span class="kt">Right</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">c</span><span class="p">))</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">Right</span> <span class="n">c</span><span class="p">)</span>
</code></pre></div></div><p>This isomorphism inductively generalizes to arbitrary finite coproducts.</p><p>We have that tensor product <code class="language-plaintext highlighter-rouge">(,)</code> distributes with finite coproducts.</p><p>Assume we have an arbitrary symmetric monoidal category with tensor product distributive over finite coproducts (frequently denoted as <em>symmetric monoidal category with finite coproducts</em>). Consider classes of isomorphic types and denote binary product as \(\cdot\), binary coproduct as \(+\), terminal object as \(1\), and initial object as \(0\).</p><p>The laws of monoidal categories we have built can be rewritten as follows:</p><ul><li> \[(a+b)+c=a+(b+c)\]<li> \[0 + a = a = a + 0\]<li> \[a + b = b + a\]<li> \[(a \cdot b) \cdot c = a \cdot (b \cdot c)\]<li> \[1 \cdot a = a = a \cdot 1\]<li> \[a \cdot b = b \cdot a\]</ul><p>Distributivity gives us equation \(a \cdot (b + c) = a \cdot b + a \cdot c\).</p><p><strong>Proposition:</strong> For any object \(a\) \(0 \cdot a = 0\). I.e. \(0 \cdot a\) is an initial object.</p><p><strong>Proof:</strong> Consider \(\operatorname{Hom}(0 \cdot a, b)\) for some \(b\). It is non-empty due to existence of the unique composition \(0 \cdot a \xrightarrow{\pi_0} \to b\). Let \(f, g \in \operatorname{Hom}(0 \cdot a, b)\). Consider \((0 \cdot a) + (0 \cdot a) = (0 + 0) \cdot a = 0 \cdot a\). There is a unique morphism from \(0\) to \(0\), hence inclusions \(i_1\) and \(i_2\) to the left and right summands coincide. Consider \(f + g : (0 \cdot a) + (0 \cdot a) \to b + b\). Compositions \((f + g) . i_1\) and $(f + g) . i_2$ are equal as $b + 0 = 0 + b$. But \((f + g) . i_1$ = f + 0 = f$ and\)(f + g) . i_2 = 0 + g = g$$.</p><p>Reference: <a href="https://ncatlab.org/nlab/show/distributive+category">ncatlab: Proposition 2.2</a>.</p><p>For the category of finite sets, this construction yields the semiring of natural numbers, as Qiaochu Yuan <a href="https://math.stackexchange.com/questions/2582771/relationship-between-algebraic-data-types-and-the-set-of-real-numbers#comment5333054_2582817">points</a> out. This is an easy exercise and we can compare it with the notation of finite ordinals used to compactly denote finite products at the start of the post.</p><p>We have also just shown that isomorphism classes of objects in \(Hask\) as a symmetric monoidal category with finite coproducts form a commutative semiring.</p><p>So do Haskell types. This construction seems to be a good answer to the question of why algebraic types are algebraic.</p><p>Actually, we have not constructed algebraic types since we excluded recursive types. And there is a valid question if the given semigroup structure extends to the whole class of algebraic types. But we did not rely on the nature of elements while proving a general statement, so there is nothing to raise a problem. Recursive types deserve at least a separate post.</p></main><footer> <a href="/blog">← Back to all writings</a> <!--<nav class="sans"><hr> <input class="menu-btn" type="checkbox" id="menu-btn" /><p><label class="menu-icon" for="menu-btn">Menu</label></p><ul class="site-nav"><li><a href="/">Home</a><li><a href="/blog">Blog</a><li><a href="/designs">Designs</a><li><a href="/about">About</a><li><a href="https://canisee.xyz" title="Confirm your vision functionality">[Can I See]</a></ul></nav>--> <!-- <span class="mini-note">You've reached the end of the page. Good job!</span> --> <!--<nav class="sans"><hr><p><label class="menu-icon" for="menu-btn">Menu</label></p><ul class="site-nav"><li><a href="/">Home</a><li><a href="/blog">Blog</a><li><a href="/designs">Designs</a><li><a href="/about">About</a><li><a href="https://canisee.xyz" title="Confirm your vision functionality">[Can I See]</a></ul></nav>--><div class="bottom-footer"> <i>Theme <a href="https://knhash.in/jekyllBear" title="the art">jekyllBear</a> built and maintained by <a href="https://knhash.in" title="the artist">knhash</a> </i></div></footer><!-- <script type="text/x-mathjax-config"> MathJax.Hub.Config({ extensions: ["tex2jax.js", "TeX/AMSmath.js"], jax: ["input/TeX", "output/SVG"], }) </script> <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=default"> </script> -->
